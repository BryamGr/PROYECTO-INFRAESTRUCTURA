- name: Build & push imágenes a ECR y aplicar Terraform
  hosts: localhost
  connection: local
  vars_files:
    - envs/prod.yml

  environment:
    AWS_ACCESS_KEY_ID: "{{ aws_access_key_id | default(omit) }}"
    AWS_SECRET_ACCESS_KEY: "{{ aws_secret_access_key | default(omit) }}"
    AWS_SESSION_TOKEN: "{{ aws_session_token | default(omit) }}"
    AWS_PROFILE: "{{ aws_profile | default(omit) }}"
    AWS_DEFAULT_REGION: "{{ aws_region }}"

  pre_tasks:
    - name: Requisitos de colecciones
      debug: { msg: "Ejecuta: ansible-galaxy collection install -r ansible/requirements.yml" }

    - name: Validar variables mínimas
      assert:
        that:
          - project_name | length > 0
          - aws_region | length > 0
          - frontend_bucket_name | length > 0
          - uploads_bucket_name | length > 0
          - db_password | length > 0
          - auth_context_dir | length > 0
          - inventario_context_dir | length > 0
          - reportes_context_dir | length > 0

  tasks:
    - name: Crear repos ECR (idempotente)
      amazon.aws.ecr_repository:
        name: "{{ ecr_repo_prefix }}/{{ item }}"
        image_tag_mutability: MUTABLE
        image_scanning_configuration: { scanOnPush: true }
      loop: [ "auth", "inventario", "reportes" ]
      register: ecr_repos

    - name: Obtener URIs de repos
      set_fact:
        ecr_auth_uri: "{{ (ecr_repos.results | selectattr('item','equalto','auth') | first).repository.repositoryUri }}"
        ecr_inv_uri:  "{{ (ecr_repos.results | selectattr('item','equalto','inventario') | first).repository.repositoryUri }}"
        ecr_rep_uri:  "{{ (ecr_repos.results | selectattr('item','equalto','reportes') | first).repository.repositoryUri }}"

    - name: Login a ECR
      amazon.aws.ecr_login:
        region: "{{ aws_region }}"

    - name: Build & Push AUTH
      community.docker.docker_image:
        name: "{{ ecr_auth_uri }}"
        tag: "{{ image_tag | default('latest') }}"
        push: true
        build: { path: "{{ auth_context_dir }}", dockerfile: Dockerfile }

    - name: Build & Push INVENTARIO
      community.docker.docker_image:
        name: "{{ ecr_inv_uri }}"
        tag: "{{ image_tag | default('latest') }}"
        push: true
        build: { path: "{{ inventario_context_dir }}", dockerfile: Dockerfile }

    - name: Build & Push REPORTES
      community.docker.docker_image:
        name: "{{ ecr_rep_uri }}"
        tag: "{{ image_tag | default('latest') }}"
        push: true
        build: { path: "{{ reportes_context_dir }}", dockerfile: Dockerfile }

    - name: Definir imágenes para Terraform
      set_fact:
        auth_image: "{{ ecr_auth_uri }}:{{ image_tag | default('latest') }}"
        inventario_image: "{{ ecr_inv_uri }}:{{ image_tag | default('latest') }}"
        reportes_image: "{{ ecr_rep_uri }}:{{ image_tag | default('latest') }}"

    # --- INICIO DE LA TAREA AÑADIDA ---
    - name: Instalar dependencias de la Lambda (mysql2, ses)
      community.general.npm:
        path: "{{ playbook_dir }}/../lambda_src" 
        ci: true 

    - name: Terraform Init & Apply
      community.general.terraform:
        project_path: "{{ playbook_dir }}/.." # Asume que tus .tf están un nivel arriba
        state: present
        force_init: true
        backend_config:
          bucket: "{{ tf_state_bucket }}"
          key: "{{ tf_state_key }}"
          region: "{{ aws_region }}"
        variables:
          aws_region: "{{ aws_region }}"
          aws_profile: "{{ aws_profile | default(omit) }}"
          aws_access_key_id: "{{ aws_access_key_id | default(omit) }}"
          aws_secret_access_key: "{{ aws_secret_access_key | default(omit) }}"
          aws_session_token: "{{ aws_session_token | default(omit) }}"

          project_name: "{{ project_name }}"
          domain_name: "{{ domain_name | default(omit) }}"
          hosted_zone_id: "{{ hosted_zone_id | default(omit) }}"
          waf_enable: "{{ waf_enable }}"
          acm_certificate_arn: "{{ acm_certificate_arn | default(omit) }}"

          frontend_bucket_name: "{{ frontend_bucket_name }}"
          auth_frontend_bucket_name: "{{ auth_frontend_bucket_name }}"
          uploads_bucket_name: "{{ uploads_bucket_name }}"

          ecr_repo_prefix: "{{ ecr_repo_prefix }}"
          auth_image: "{{ auth_image }}"
          inventario_image: "{{ inventario_image }}"
          reportes_image: "{{ reportes_image }}"

          db_engine: "{{ db_engine }}"
          db_engine_version: "{{ db_engine_version }}"
          db_instance_class: "{{ db_instance_class }}"
          db_name: "{{ db_name }}"
          db_username: "{{ db_username }}"
          db_password: "{{ db_password }}"

          inventario_port: "{{ inventario_port }}"
          reportes_port: "{{ reportes_port }}"
          auth_port: "{{ auth_port }}"
          desired_count_auth: "{{ desired_count_auth }}"
          desired_count_inventario: "{{ desired_count_inventario }}"
          desired_count_reportes: "{{ desired_count_reportes }}"

          enable_nat_gateway: "{{ enable_nat_gateway }}"
          api_stage_name: "{{ api_stage_name }}"
          jwt_secret: "{{ jwt_secret }}"
          tags: "{{ tags }}"


    - name: Subir Dashboard a S3
      when: enable_frontend | default(false)
      command: >
        aws s3 sync "{{ dashboard_src_dir }}"
        "s3://{{ frontend_bucket_name }}/"
        --delete
      changed_when: false

    - name: Subir Auth a S3
      when: enable_frontend | default(false)
      command: >
        aws s3 sync "{{ auth_src_dir }}"
        "s3://{{ auth_frontend_bucket_name }}/"
        --delete
      changed_when: false

    - name: Obtener ID de la distribución de CloudFront (si existe)
      when: enable_frontend | default(false)
      shell: terraform output -raw cloudfront_distribution_id
      args:
        chdir: "{{ playbook_dir }}/.."
      register: cfid_result
      changed_when: false
      failed_when: false

    - name: Guardar ID si es válido
      when: enable_frontend | default(false)
      set_fact:
        cfid: "{{ (cfid_result.stdout | default('')) | trim }}"
      changed_when: false

    - name: Invalidar CloudFront (index de dashboard y auth)
      when:
        - enable_frontend | default(false)
        - cfid is defined
        - cfid | length > 0
      command: >
        aws cloudfront create-invalidation
        --distribution-id "{{ cfid }}"
        --paths "/Dashboard/index.html" "/auth/index.html"
      register: invalidation
      changed_when: true
